#!/usr/bin/env python

"""
Select datasets based on tags and descriptors.  Useful to create
reduce input lists.  Looks at datasets on disk.
"""

from __future__ import print_function

import sys
import argparse
import glob

from gempy.adlibrary import dataselect

SHORT_DESCRIPTION = "Find files that matches certain criteria defined by tags " \
                    "and expression involving descriptors."


def parse_args(command_line_args):
    """
    Parse the command line.
    """
    parser = argparse.ArgumentParser(description=SHORT_DESCRIPTION)
    parser.add_argument('inputs', type=str, nargs="+",
                        help="Input FITS file")
    parser.add_argument('--tags', '-t', type=str, nargs=1,
                        dest='tags', action='store', required=False,
                        help='Comma-separated list of required tags.')
    parser.add_argument('--xtags', type=str, nargs=1,
                        dest='xtags', action='store', required=False,
                        help='Comma-separated list of tags to exclude')
    parser.add_argument('--expr', type=str, nargs=1,
                        dest='expression', action='store', required=False,
                        help='Expression to apply to descriptors (and tags)')
    parser.add_argument('--strict', default=False, action='store_true',
                        help='Toggle on strict expression matching for '
                             'exposure_time (not just close) and for '
                             'filter_name (match component number).')
    parser.add_argument('--output', '-o', nargs=1,
                        dest='output', action='store', required=False,
                        help='Name of the output file')
    parser.add_argument('--adpkg', nargs=1,
                        dest='adpkg', action='store', required=False,
                        help='Name of the astrodata instrument package to use'
                             'if not gemini_instruments')
    parser.add_argument('--verbose', '-v', default=False, action='store_true',
                        help='Toggle verbose mode when using -o')
    parser.add_argument('--debug', default=False, action='store_true',
                        help='Toggle debug mode')

    args = parser.parse_args(command_line_args)

    inputs = []
    for pattern in args.inputs:
        inputs.extend(glob.glob(pattern))
    args.inputs = inputs

    if args.tags is None:
        args.tags = []
    else:
        args.tags = args.tags[0].split(',')
    if args.xtags is None:
        args.xtags = []
    else:
        args.xtags = args.xtags[0].split(',')

    if args.adpkg is not None:
        args.adpkg = args.adpkg[0]

    if args.debug:
        print(args)

    return args

def main(argv=None):
    """
    Print or send to file the filename of the datasets that match the
    selection criteria provided on the command line.
    """

    if argv is None:
        argv = sys.argv[1:]

    args = parse_args(argv)

    if args.expression is None:
        codified_expression = 'True'
        args.expression = [None]
    else:
        codified_expression = dataselect.expr_parser(args.expression[0],
                                                     args.strict)

    if args.output is None:
        args.verbose = True

    selected_data = dataselect.select_data(args.inputs, args.tags, args.xtags,
                                codified_expression, adpkg=args.adpkg)

    # write to screen and/or to file
    if args.output is not None:
        fh = open(args.output[0], 'w')
        dataselect.writeheader(fh, args.tags, args.xtags, args.expression[0])
    for filename in selected_data:
        if args.verbose:
            print(filename)
        if args.output is not None:
            fh.write(filename+'\n')
    if args.output is not None:
        fh.close()



if __name__ == '__main__':
    sys.exit(main())